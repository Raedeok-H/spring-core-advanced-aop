** 포인트컷 지시자
- 포인트 컷 표현식을 포함한 포인컷에 대해서 알아보낟.
애스팩트J는 포인트컷을 편리하게 표현하기 위한 특별한 표현식을 제공한다.
    ex) @Pointcut("execution(* hello.aop.order..*(..))")
포인트컷 표현식은 AspectJ pointcut expression, 즉 애스팩트J가 제공하는 포인트컷 표현식을 줄여서 말하는 것이다.

** 포인트컷 지시자
포인트컷 표현식은 'execution' 같은 포인트컷 지시자(Pointcut Designator)로 시작한다. 줄여서 PCD라 한다.

** 포인트컷 지시자의 종류
execution: 메소드 실행 조인 포인트를 매칭한다. 스프링 AOP에서 가장 많이 사용하고, 기능도 복잡하다.
within: 특정 타입 내의 조인 포인트를 매칭한다.
args: 인자가 주어진 타입의 인스턴스인 조인 포인트
this: 스프링 빈 객체(스프링 AOP 프록시)를 대상으로 하는 조인 포인트
target: Target 객체(스프링 AOP 프록시가 가르키는 실체 대상)를 대상으로 하는 조인 포인트
@target: 실행 객체의 클래스에 주어진 타입의 애노테이션이 있는 조인포인트
@within: 주어진 애노테이션이 있는 타입 내 조인 포인트
@annotation: 메서드가 주어진 애노테이션을 가지고 있는 조인 포인트를 매칭
@args: 전달된 실제 인수의 런타임 타입이 주어진 타입의 애노테이션을 갖는 조인 포인트
bean: 스프링 전용 포인트컷 지시자, 빈의 이름으로 포인트컷을 지정한다.

- execution은 가장 많이 사용하고, 나머지는 자주 사용하지 않는다. 따라서 execution을 중점적으로 이해하자.

** execution 문법
   execution(modifiers-pattern? ret-type-pattern declaring-type-pattern?name-pattern(param-pattern) throws-pattern?)
   execution(접근제어자?          반환타입           선언타입?                 메서드이름(파라미터)          예외?)
       - 메소드 실행 조인 포인트를 매칭한다.
       - ?는 생략할 수 있다.
       - * 같은 패턴을 지정할 수 있다.
       - 파라미터에서 .. 은 파라미터의 타입과 파라미터 수가 상관없다는 뜻
패키지에서 . 와 .. 의 차이를 이해해야한다.
    .: 정확하게 해당 위치의 패키지
    ..: 해당 위치의 패키지와 그 하위 패키지도 포함


타입 매칭 - 부모 타입 허용(부모타입으로 매칭시 자식타입도 매칭된다)
타입 매칭 - 부모 타입에 있는 메서드만 허용(부모타입으로 자식타입까지 매칭 되었을 때, 자식타입의 메소드는 부모타입에 있는 것만 매칭된다.)
파라미터 매칭 - execution 파라미터 매칭 규칙은 다음과 같다.
          - (String) : 정확하게 String 타입 파라미터
          - () : 파라미터가 없어야 한다.
          - (*) : 정확히 하나의 파라미터, 단 모든 타입을 허용한다.
          - (*, *) : 정확히 두 개의 파라미터, 단 모든 타입을 허용한다.
          - (..) : 숫자와 무관하게 모든 파라미터, 모든 타입을 허용한다. 참고로 파라미터가 없어도 된다. 0..* 로 이해하면 된다.
          - (String, ..) : String 타입으로 시작해야 한다. 숫자와 무관하게 모든 파라미터, 모든 타입을 허용한다.
                예) (String) , (String, Xxx) , (String, Xxx, Xxx) 허용



** within
within 지시자는 "특정 타입" 내의 조인 포인트들로 매칭을 제한한다.
쉽게 이야기해서 해당 타입이 매칭되면 그 안의 메서드(조인 포인트)들이 자동으로 매칭된다.
문법은 단순한데 execution 에서 "타입 부분만" 사용한다고 보면 된다
 - 주의해야 할 점이 있다. 표현식에 "부모 타입을 지정하면 안된다"는 점이다.
   정확하게 타입이 맞아야 한다. 이 부분에서 execution 과 차이가 난다.


** args
args : 인자가 주어진 타입의 인스턴스인 조인 포인트로 매칭
기본 문법은 execution 의 args 부분과 같다.
- execution과 args의 차이점
    execution 은 파라미터 타입이 정확하게 매칭되어야 한다. execution 은 클래스에 선언된 정보를 기반으로 판단한다.
    args 는 부모 타입을 허용한다. args 는 실제 넘어온 파라미터 객체 인스턴스를 보고 판단한다
- 참고: args 지시자는 단독으로 사용되기 보다는 뒤에서 설명할 파라미터 바인딩에서 주로 사용된다.


this, target 순서인데 어렵기 때문에 마지막으로 순서 변경

** @target, @within
@target : 실행 객체의 클래스에 주어진 타입의 애노테이션이 있는 조인 포인트
@within : 주어진 애노테이션이 있는 타입 내 조인 포인트
- 설명
 @target , @within 은 다음과 같이 타입에 있는 애노테이션으로 AOP 적용 여부를 판단한다.
     ex)
        @target(hello.aop.member.annotation.ClassAop)
        @within(hello.aop.member.annotation.ClassAop)

- @target vs @within
    @target 은 인스턴스의 모든 메서드(부모의 메서드도)를 조인 포인트로 적용한다.
    @within 은 해당 타입 내에 있는 메서드만 조인 포인트로 적용한다.
        - 쉽게 이야기해서 @target 은 "부모 클래스"의 메서드까지 어드바이스를 다 적용하고,
          @within 은 "자기 자신의 클래스"에 정의된 메서드에만 어드바이스를 적용한다.

- 참고: @target , @within 지시자는 뒤에서 설명할 파라미터 바인딩에서 함께 사용된다.

- 주의: [args, @args, @target] 포인트컷 지시자는 단독으로 사용하면 안된다.
      이번 예제를 보면 execution(* hello.aop..*(..)) 를 통해 적용 대상을 줄여준 것을 확인할 수 있다.
      왜나하면 args , @args , @target 은 실제 객체 인스턴스가 생성되고 실행될 때 어드바이스 적용 여부를 확인할 수 있다.
       -> 실행시점에 일어나는 포인트컷 적용여부도 결국 프록시가 있어야 판단할 수 있다.
            -> 스프링 컨테이너가 만들어지는 애플리케이션 로딩 시점에 프록시가 적용가능하다.
                -> args , @args , @target 같은 포인트컷 지시자가 있으면 스 프링은 모든 스프링 빈에 AOP를 적용하려고 시도한다.
                   앞서 설명한 것 처럼 프록시가 없으면 실행 시점에 판단 자체가 불가능하다
       -> 문제는 이렇게 모든 스프링 빈에 AOP 프록시를 적용하려고 하면,
          스프링이 내부에서 사용하는 빈 중에는 final 로 지정된 빈들도 있기 때문에 오류가 발생할 수 있다.
          따라서 이러한 표현식은 최대한 프록시 적용 대상을 축소하는 표현식과 함께 사용해야 한다.


** @annotation
@annotation : 메서드가 주어진 애노테이션을 가지고 있는 조인 포인트를 매칭
    ex) @annotation(hello.aop.member.annotation.MethodAop)

** @args
@args: 전달된 실제 인수의 런타임 타입이 주어진 타입의 애노테이션을 갖는 조인 포인트
- 설명: 전달된 인수의 런타임 타입에 @Check 애노테이션이 있는 경우에 매칭한다.
       ex) args(~.Check) => @Check 애노테이션이 있는 인수에 경우에 매칭한다.
잘 쓰진 않아서 설명만 하고 넘어감.


** bean
bean : 스프링 전용 포인트컷 지시자, 빈의 이름으로 지정한다.
- 설명
    스프링 빈의 이름으로 AOP 적용 여부를 지정한다. 이것은 스프링에서만 사용할 수 있는 특별한 지시자이다.
        ex) bean(orderService) || bean(*Repository)
    * 과 같은 패턴을 사용할 수 있다.
