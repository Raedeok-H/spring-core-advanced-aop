@Aspect 를 사용하려면 @EnableAspectJAutoProxy 를 스프링 설정에 추가해야 하지만,
스프링 부트를 사용하면 자동으로 추가된다.

** 참고
- 스프링 AOP는 AspectJ의 문법을 차용하고, 프록시 방식의 AOP를 제공한다. AspectJ를 직접 사용하는 것이아니다.
- 스프링 AOP를 사용할 때는 @Aspect 애노테이션을 주로 사용하는데, 이 애노테이션도 AspectJ가 제공하는 애노테이션이다.

** 참고
@Aspect 를 포함한 org.aspectj 패키지 관련 기능은 aspectjweaver.jar 라이브러리가 제공하는 기능이다.
앞서 build.gradle 에 spring-boot-starter-aop 를 포함했는데,
이렇게 하면 스프링의 AOP 관련 기능과 함께 aspectjweaver.jar 도 함께 사용할 수 있게 의존 관계에 포함된다.
그런데 스프링에서는 AspectJ가 제공하는 "애노테이션"이나 "관련 인터페이스만 사용"하는 것이고, 실제 AspectJ
가 제공하는 컴파일, 로드타임 위버 등을 사용하는 것은 아니다.
 ***스프링은 지금까지 학습한 것 처럼 프록시방식의 AOP를 사용한다

** @Aspect 는 애스펙트라는 표식이지 컴포넌트 스캔이 되는 것은 아니다.
   따라서 AspectV1 를 AOP로 사용하려면 스프링 빈으로 등록해야 한다.
- 스프링 빈으로 등록하는 방법은 다음과 같다.
   1.@Bean 을 사용해서 직접 등록
   2.@Component 컴포넌트 스캔을 사용해서 자동 등록
   3.@Import 주로 설정 파일을 추가할 때 사용( @Configuration )
        - @Import 는 주로 설정 파일을 추가할 때 사용하지만,
          이 기능으로 스프링 빈도 등록할 수 있다.
          테스트에서는 버전을 올려가면서 변경할 예정이어서 간단하게 @Import 기능을 사용.

** @Pointcut
- @Pointcut 에 포인트컷 표현식을 사용한다.
- 메서드 이름과 파라미터를 합쳐서 포인트컷 시그니처(signature)라 한다.
- 메서드의 반환 타입은 void 여야 한다.
- 코드 내용은 비워둔다.
- 여기서 포인트컷 시그니처는 allOrder() 이다. 이름 그대로 주문과 관련된 모든 기능을 대상으로 하는 포인트컷이다.
- @Around 어드바이스에서는 포인트컷을 직접 지정해도 되지만, 포인트컷 시그니처를 사용해도 된다.
  여기서는@Around("allOrder()") 를 사용한다.
- private, public 같은 접근 제어자는 내부에서만 사용하면 private 을 사용해도 되지만,
  다른 애스팩트에서 참고하려면 public 을 사용해야 한다.
=>결과적으로 AspectV1 과 같은 기능을 수행한다.
이렇게 분리하면 하나의 포인트컷 표현식을 여러 어드바이스에서 함께 사용할 수 있다.
그리고 뒤에 설명하겠지만 다른 클래스에 있는 외부 어드바이스에서도 포인트컷을 함께 사용할 수 있다.

** 포인트컷 조합
- @Around("allOrder() && allService()")
    -포인트컷은 이렇게 조합할 수 있다. && (AND), || (OR), ! (NOT) 3가지 조합이 가능하다.
- allService() 포인트컷은 타입 이름 패턴이 *Service 를 대상으로 하는데,
  쉽게 이야기해서 XxxService 처럼 Service 로 끝나는 것을 대상으로 한다. *Servi* 과 같은 패턴도 가능하다.
  여기서 타입 이름 패턴이라고 한 이유는 "클래스, 인터페이스에 모두 적용"되기 때문이다.

AOP 적용 전
    클라이언트 -> orderService.orderItem() -> orderRepository.save()
AOP 적용 후
    클라이언트 -> [ doLog() -> doTransaction() ] -> orderService.orderItem()
            ->  [doLog()] -> orderRepository.save()
- orderService 에는 doLog() , doTransaction() 두가지 어드바이스가 적용되어 있고,
  orderRepository 에는 doLog() 하나의 어드바이스만 적용된 것을 확인할 수 있다.

그런데 여기에서 로그를 남기는 순서가 [ doLog() -> doTransaction() ] 순서로 작동한다.
트랜잭션과 관련된 시간을 제외하고 측정하고 싶다면 [ doTransaction()-> doLog() ] 이렇게 트랜잭션 이후에 로그를 남겨야 할 것이다.

그 전에 잠깐 포인트컷을 외부로 빼서 사용하는 방법을 먼저 알아보자.

다음과 같이 포인트컷을 공용으로 사용하기 위해 별도의 외부 클래스에 모아두어도 된다.
참고로 외부에서 호출할 때는 포인트컷의 접근 제어자를 public 으로 열어두어야 한다.
외부에 있는 포인트 컷을 사용하는 방법은 패키지명을 포함한 클래스 이름과 포인트컷 시그니처를 모두 지정하면 된다.

** 어드바이스는 기본적으로 순서를 보장하지 않는다.
@Aspect 적용 단위로 org.springframework.core.annotation.@Order 애노테이션을 적용해야 한다.
문제는 이것을 어드바이스 단위가 아니라 "클래스 단위로 적용"할 수 있다는 점이다.
그래서 지금처럼 하나의 애스펙트에 여러 어드바이스가 있으면 "순서를 보장 받을 수 없다."
따라서 "애스펙트를 별도의 클래스로 분리"해야 한다.



** 어드바이스 종류
어드바이스는 앞서 살펴본 @Around 외에도 여러가지 종류가 있다.
-@Around : 메서드 호출 전후에 수행, 가장 강력한 어드바이스,
          조인 포인트 실행 여부 선택, 반환 값 변환, 예외 변환 등이 가능
-@Before : 조인 포인트 실행 이전에 실행
-@AfterReturning : 조인 포인트가 정상 완료후 실행
-@AfterThrowing : 메서드가 예외를 던지는 경우 실행
-@After : 조인 포인트가 정상 또는 예외에 관계없이 실행(finally 의 개념)

복잡해 보이지만 사실 @Around 를 제외한 나머지 어드바이스들은 @Around 가 할 수 있는 일의 일부만 제공할 뿐이다.
따라서 @Around 어드바이스만 사용해도 필요한 기능을 모두 수행할 수 있다.

참고 정보 획득
모든 어드바이스는 org.aspectj.lang.JoinPoint 를 첫번째 파라미터에 사용할 수 있다. (생략해도 된다.)
단 @Around 는 ProceedingJoinPoint 을 "사용해야 한다."
    => 참고로 ProceedingJoinPoint 는 JoinPoint 의 하위 타입이다.

JoinPoint 인터페이스의 주요 기능
    getArgs() : 메서드 인수를 반환합니다.
    getThis() : 프록시 객체를 반환합니다.
    getTarget() : 대상 객체를 반환합니다.
    getSignature() : 조언되는 메서드에 대한 설명을 반환합니다.
    toString() : 조언되는 방법에 대한 유용한 설명을 인쇄합니다.
ProceedingJoinPoint 인터페이스의 주요 기능
    proceed() : 다음 어드바이스나 타켓을 호출한다.
      + JoinPoint 의 기능

추가로 호출시 전달한 매개변수를 파라미터를 통해서도 전달 받을 수도 있는데, 이 부분은 뒤에서 설명한다.

순서
┌----------------------------- ------------------------------어드바이스 적용 순서------------------------------------------------------------┐
│                           @Around----->>@Before----->>@After----->>@AfterReturning----->>@AfterThrowing                                 │
└-----------------------------------------------------------------------------------------------------------------------------------------┘
***어드바이스가 적용되는 순서는 이렇게 적용되지만, 호출 순서와 리턴 순서는 반대라는 점을 알아두자.

┌------------------------------------------------------------실제 표출 순서-----------------------------------------------------------------┐
│                                                                                                                                         │
│                       @Around        @Before          @After        @AfterReturning         @AfterThrowing                              │
│   클라이언트가 호출 ->>---(1)----->>-----(2)--------------------------------------------------------------------->>--Service 가 받음 -–┐   │
│                                                                                                                                     │   │
│   클라이언트에게 반환-<<--(6)-----<<----------------------(5)--<<------------(4)--<<---------------(3)----------<<--Service 가 응답-<<-┘   │
│                                                                                                                                         │
└-----------------------------------------------------------------------------------------------------------------------------------------┘
물론 @Aspect 안에 동일한 종류의 어드바이스가 2개 있으면 순서가 보장되지 않는다.
이 경우 앞서 배운 것 처럼 @Aspect 를 분리하고 @Order 를 적용하자.


@Around 외에 다른 어드바이스가 존재하는 이유
@Around 하나만 있어도 모든 기능을 수행할 수 있다. 그런데 다른 어드바이스들이 존재하는 이유는 무엇일까?

@Around 는 항상 joinPoint.proceed() 를 호출해야 한다.
만약 실수로 호출하지 않으면 타켓이 호출되지 않는 치명적인 버그가 발생한다.
    => 좋은 설계는 제약이 있는 것이다
        -> @Around 만 있으면 되는데 왜? 이렇게 제약을 두는가? 제약은 실수를 미연에 방지한다. 일종의 가이드 역할을 한다.
        -> 제약 덕분에 역할이 명확해진다. 다른 개발자도 이 코드를 보고 고민해야 하는 범위가 줄어들고 코드의 의도도 파악하기 쉽다.
