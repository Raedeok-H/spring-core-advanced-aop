** 프록시와 내부 호출 - 문제
    스프링은 프록시 방식의 AOP를 사용한다.
    따라서 AOP를 적용하려면 항상 프록시를 통해서 대상 객체(Target)을 호출해야 한다.
    이렇게 해야 프록시에서 먼저 어드바이스를 호출하고, 이후에 대상 객체를 호출한다.
    만약 프록시를 거치지 않고 대상 객체를 "직접 호출"하게 되면 AOP가 적용되지 않고, 어드바이스도 호출되지 않는다.
    AOP를 적용하면 스프링은 대상 객체 대신에 프록시를 스프링 빈으로 등록한다.
    따라서 스프링은 의존관계 주입시에 항상 프록시 객체를 주입한다.
    프록시 객체가 주입되기 때문에 대상 객체를 직접 호출하는 문제는 일반적으로 발생하지 않는다.
    하지만 "대상 객체의 내부에서 메서드 호출이 발생하면 프록시를 거치지 않고 대상 객체를 직접 호출하는 문제"가발생한다.
        - 실무에서 반드시 한번은 만나서 고생하는 문제이기 때문에 꼭 이해하고 넘어가자.
        - 예제를 통해서 내부 호출이 발생할 때 어떤 문제가 발생하는지 알아보자. 먼저 내부 호출이 발생하는 예제를 만들어보자.

    - 프록시 방식의 AOP 한계
    스프링은 프록시 방식의 AOP를 사용한다. 프록시 방식의 AOP는 메서드 내부 호출에 프록시를 적용할 수 없다.
    지금부터 이 문제를 해결하는 방법을 하나씩 알아보자.
     +) AspectJ는 된다. 하지만 복잡하다.

** 대안 1 자기 자신 주입(스프링 부트 2.6 이상 부터 순환 참조를 아예 막아놓았다.)
    이제는 internal() 을 호출할 때 자기 자신의 인스턴스를 호출하는 것이 아니라,
    프록시 인스턴스를 통해서 호출하는 것을 확인할 수 있다. 당연히 AOP도 잘 적용된다.

** 대안2 지연 조회
    앞서 대안 1에서 생성자로 주입을 할 수 없는 이유는 자기 자신을 생성하면서 주입해야 하기 때문이다.
    이 경우 수정자 주입을 사용하거나, "지연 조회"를 사용하면 된다.
    스프링 빈을 지연해서 조회하면 되는데,
    ObjectProvider(Provider), ApplicationContext 를 사용하면 된다.

** 대안3 구조 변경
   앞선 방법들은 자기 자신을 주입하거나 또는 Provider 를 사용해야 하는 것 처럼 조금 어색한 모습을 만들었다.
   가장 나은 대안은 내부 호출이 발생하지 않도록 구조를 변경하는 것이다.
   실제 이 방법을 가장 권장한다

   여기서 구조를 변경한다는 것은 이렇게 단순하게 분리하는 것 뿐만 아니라 다양한 방법들이 있을 수 있다.
   예를 들어서 다음과 같이 클라이언트에서 둘다 호출하는 것이다.
       클라이언트 -> external()
       클라이언트 -> internal()
   물론 이 경우 external() 에서 internal() 을 내부 호출하지 않도록 코드를 변경해야 한다.
   그리고 클라이언트가 external() , internal() 을 모두 호출하도록 구조를 변경하면 된다. (물론 가능한 경우에 한해서)

     +) AOP는 주로 트랜잭션 적용이나 주요 컴포넌트의 로그 출력 기능에 사용된다.
        쉽게 이야기해서 인터페이스에 메서드가 나올 정도의 규모에 AOP를 적용하는 것이 적당하다.
        더 풀어서 이야기하면 AOP는 public 메서드에만 적용한다.
        private 메서드처럼 작은 단위에는 AOP를 적용하지 않는다.
     +) AOP 적용을 위해 private 메서드를 외부 클래스로 변경하고 public 으로 변경하는 일은 거의 없다.
     +) 그러나 예제와 같이 public 메서드에서 public 메서드를 내부 호출하는 경우에는 문제가 발생한다.
        실무에서 꼭 한번은 만나는 문제이기에 이번에 다루었다.

   *** AOP가 잘 적용되지 않으면 내부 호출을 의심해보자.



** 프록시 기술과 한계 - 타입 캐스팅
    구체 클래스만 있는 경우에는 CGLIB 를 사용해야만 하지만,
    인터페이스가 있는 경우에는 JDK 동적 프록시, CGLIB 중 선택할 수 있다.

    ** JDK 동적 프록시 한계
        인터페이스 기반으로 프록시를 생성하는 JDK 동적 프록시는 구체 클래스로 타입 캐스팅이 불가능한 한계가 있다.
        어떤 한계인지는 코드를 통해 알아보자.(이전에 다룬 것이긴 함)
    코드로 테스트한 결과: JDK 동적 프록시는 구체 클래스로 캐스팅이 되지 않고,
                       CGLIB 프록시는 구체클래스로 캐스팅이 된다.
    JDK 동적프록시는 인터페이스를 기반으로 프록시를 생성하고,
    CGLIB 프록시는 구체 클래스를 기반으로 프록시를 생성하기 때문에,
    아래와 같은 원리이다.
            부모타입 선언 = 자식 타입 대입 => 가능
            자식타입 선언 = 부모 타입 대입 => 불가능

    - 문제는 의존관계 주입시에 발생한다.